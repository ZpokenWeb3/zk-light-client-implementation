// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.20;

import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {IRiscZeroVerifier} from "./IRiscZeroVerifier.sol";


/// @title NearBlockVerification contract for proof verification and saving the results
contract NearVerifierRiscZero is OwnableUpgradeable, PausableUpgradeable {
    /// @custom:storage-location erc7201:near.block.verification.storage
    struct Layout {
        IRiscZeroVerifier _verifier;
        mapping(bytes32 => bool) proofedHashes;
        mapping(uint64 => bytes) savedEpochHashes;
        uint64 heightCheckpoint;
        bytes32 imageID;
    }

    // keccak256(abi.encode(uint256(keccak256("near.block.verification.storage")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant STORAGE_LOCATION = 0x7e1ac6ea8c17a8ee916e4637e2ea51559be498738ae8f34b89590ade1015f100;

    /// @notice Private function to retrieve storage layout
    function _getStorage() private pure returns (Layout storage $) {
        assembly {
            $.slot := STORAGE_LOCATION
        }
    }

    // Decodable output from random block proving
    struct PublicValuesRandom {
        uint32 selector;
        bytes32 currentBlockHash;
        bytes32 currentEpochHash;
        bytes32 previousEpochHash;
    }

    /// @notice Event emitted when a proof is successfully verified and Near block hash saved
    /// @param input the public inputs used in the verification
    /// @param proof the proof used for verification
    event ProofVerifiedAndSaved(bytes indexed input, bytes proof);


    /// @notice Initializes the NearBlockVerification contract
    /// @dev Only callable once, and only callable by deployer
    /// @param verifier the initial Verifier contract address
    /// @param height the initial height as checkpoint for Epoch E_0
    /// @param previousHash the B_n-1 block hash for Epoch E_0 
    /// @param currentHash the B_0 block hash for Epoch E_0 
    /// @param imageID the hash of program used in proof verification
    function initialize(address verifier, uint64 height, bytes32 previousHash, bytes32 currentHash, bytes32 imageID) external initializer {
        Layout storage $ = _getStorage();
        $._verifier = IRiscZeroVerifier(verifier);

        bytes memory concatenated = new bytes(64);
    
        assembly {
            mstore(add(concatenated, 32), previousHash)
            mstore(add(concatenated, 64), currentHash)
        }

        $.heightCheckpoint = height;
        $.savedEpochHashes[height] = concatenated;
        $.imageID = imageID;

        _transferOwnership(msg.sender);
    }

    // /// @notice Gets the verifier contract address
    // /// @return the address of the Verifier contract
     function getVerifier() external view returns (IRiscZeroVerifier) {
         return _getStorage()._verifier;
     }

     /// @notice Sets a new Verifier contract address
     /// @dev Only callable by the owner
     // / @param verifier the new Verifier contract address
     function setVerifier(address verifier) external onlyOwner {
         Layout storage $ = _getStorage();
          $._verifier = IRiscZeroVerifier(verifier);
     }

    /// @notice Change hash of the program
    /// @dev Only callable by the owner
    function setImageID(bytes32 imageID) external onlyOwner {
        Layout storage $ = _getStorage();
        $.imageID = imageID;
    }

    /// @notice Pauses execution of the verification functions in the contract
    /// @dev Only callable by the owner
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpauses execution of the verification functions in the contract
    /// @dev Only callable by the owner
    function unpause() external onlyOwner {
        _unpause();
    }

    /// @notice Saves Near hashes for Epoch and setup the height checkpoint 
    /// @dev The inputs consists of a previous block hash and a block hash B_0.
    /// @param previousHash the hash of block B_n-1
    /// @param currentHash the hash of block B_0
    /// @param height the parameter of latest checkpoint generated by proving
    function saveEpochHashesAndSetCheckpoint(bytes32 previousHash, bytes32 currentHash, uint64 height) public whenNotPaused onlyOwner {
        Layout storage $ = _getStorage();

        require($.savedEpochHashes[height].length == 0, "Height already exists");
        // Check if the checkpoint corresponds to the height for the previous epoch
        require(height - $.heightCheckpoint - 43200 >= 0, "Height is incorrect: the checkpoint must be for the previous Epoch.");

        bytes memory concatenated = new bytes(64);
    
        assembly {
            mstore(add(concatenated, 32), previousHash)
            mstore(add(concatenated, 64), currentHash)
        }

        // save the checkpoint and block hashes
        $.heightCheckpoint = height;
        $.savedEpochHashes[height] = concatenated;
    }

    /// @notice Retrieve latest height checkpoint of proved Epoch
    function getLatestCheckpoint() public view returns (uint64) {
        return _getStorage().heightCheckpoint;
    }

    /// @notice Retrieve the proved B_n-1 block hash and a B_0 block hash for E_0 by B_0 height 
    /// @param height The variable used of B_0 block for Epoch E_0
    /// @return previousHash The previous block hash
    /// @return currentHash The current block hash
    function getEpochHashesByHeight(uint64 height) public view returns (bytes32 previousHash, bytes32 currentHash) {
        Layout storage $ = _getStorage();

        // Check if the height exists in savedEpochHashes
        bytes memory savedHash = $.savedEpochHashes[height];

        require(savedHash.length != 0, "Height not found in storage.");

        // Decode the saved hash into two bytes32 values
        assembly {
            previousHash := mload(add(savedHash, 32))
            currentHash := mload(add(savedHash, 64))
        }
    }


     /// @notice Verifies a proof and save the Near block hash
     /// @dev The public outputs consists of first byte selector - 0, and 3 hashes:
     /// current block hash, epoch B_0, B_n-1
     /// @param journal the public outputs for the proof
     /// @param proof the proof to be verified
     function verifyAndSaveProof(bytes calldata journal, bytes calldata proof) public whenNotPaused {
         Layout storage $ = _getStorage();

         PublicValuesRandom memory values = abi.decode(journal, (PublicValuesRandom));

         require(values.selector == 0x00, "Selector of input must be 0");

         // verify the proof using the Verifier contract
         $._verifier.verify(proof, $.imageID, sha256(journal));

         // save the Near block hash as proofed
         $.proofedHashes[values.currentBlockHash] = true;
         emit ProofVerifiedAndSaved(journal, proof);
     }

    /// @notice Checks whether the specified public input has been checked and saved
    /// @dev The public input represents 3 Near block hashes - proved Block and 2 epochal B_0 and B_n-1
    /// @param input the public input to check for proof status
    /// @return a boolean indicating whether the input is proofed or not
    function isProofed(bytes calldata input) public view returns (bool) {
        PublicValuesRandom memory values = abi.decode(input, (PublicValuesRandom));
        return _getStorage().proofedHashes[values.currentBlockHash];
    }

    /// @notice Checks whether the specified Near block hash has been checked and saved
    /// @dev The Near block hash is represented as a byte array
    /// @param hash the hash to check for proof status
    /// @return a boolean indicating whether the hash is proofed or not
    function isProofedHash(bytes32 hash) public view returns (bool) {
        return _getStorage().proofedHashes[hash];
    }
}