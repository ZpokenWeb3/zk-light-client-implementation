use alloy_sol_types::SolType;
use clap::{Parser, ValueEnum};
use std::fs;

use near_primitives_core::borsh::to_vec;
use near_primitives_core::hash::CryptoHash;
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, VerifierContext};

use lib::rpc::ARCHIVAL_RPC;
use lib::types::types::PublicValuesEpoch;
use lib::{rpc::JsonClient, types::types::EPOCH_DURATION};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    NEAR_RISC0_ELF, NEAR_RISC0_ID
};

const PATH: &str = "./hash";

#[derive(ValueEnum, Clone, Debug, Eq, PartialEq)]
enum Mode {
    STARK,
    SNARK,
}

#[derive(Parser)]
struct Cli {
    /// Mode of operation: either generating STARK or SNARK proofs
    #[arg(short, long)]
    mode: Mode,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let Cli {
        mode,
    } = Cli::parse();

    loop {
        // Read last know height. It is the height of B0 of Ei.
        let path = format!("{PATH}/last_known_height.json");
        let height_string = fs::read_to_string(path).expect("Height reading error.");
        let last_known_height: u64 = height_string.parse::<u64>().expect("Error parsing height.");

        println!("The last known height is: {}", last_known_height);

        let mut last_block_height: u64 = last_known_height + (EPOCH_DURATION - 1);
        let mut first_block_height: u64 = last_known_height + EPOCH_DURATION;

        let mut client = JsonClient::setup(Some(ARCHIVAL_RPC.to_string())).expect("Error setup client");

        // Load block with last known height B0 Ei-1. 
        let (mut lkb_hash,  lkb_block) = client.load_block_by_height_from_rpc(last_known_height).await?;
        // Initialize new blocks.
        let (mut epoch_id_i_1_hash_last, mut epoch_id_i_1_block_last) = (lkb_hash.clone(), lkb_block.clone());
        let (mut epoch_id_i_hash_0, mut epoch_id_i_block_0) = (lkb_hash.clone(), lkb_block.clone());

        // Load new blocks.
        loop {
            // Load Bn-1 Ei.
            (epoch_id_i_1_hash_last, epoch_id_i_1_block_last) = client.load_block_by_height_from_rpc(last_block_height).await?;
            // Load B0 Ei.
            (epoch_id_i_hash_0, epoch_id_i_block_0) = client.load_block_by_height_from_rpc(first_block_height).await?;
            if (CryptoHash(lkb_block.epoch_id().0.0) == CryptoHash(epoch_id_i_1_block_last.epoch_id().0.0))
                && (epoch_id_i_1_hash_last == CryptoHash(epoch_id_i_block_0.next_epoch_id().0.0))
                && (epoch_id_i_1_hash_last == CryptoHash(epoch_id_i_block_0.prev_hash().0))
            {
                break;
            }
            last_block_height += 1;
            first_block_height += 1;
        }

        // Search & load hashes from files.
        // Load stored hash of B0 Ei-1 for new B0 Ei.
        let hash = lkb_hash.to_string();
        println!("search for: {}", hash);
        let path = format!("{PATH}/{hash}/hash.json");
        let epoch_id_i_1_hash_0: String = fs::read_to_string(path).expect("Hash reading error.");
        // Load stored Bn-1 Ei-2 for new B0 Ei & Bn-1 Ei-1.
        let hash = lkb_block.next_epoch_id().0.to_string();
        println!("search for: {}", hash);
        let path = format!("{PATH}/{hash}/hash.json");
        let epoch_id_i_2_hash_last: String = fs::read_to_string(path).expect("Hash reading error.");
        let (_, epoch_id_i_2_block_last) = client.load_block_by_hash_from_rpc(&epoch_id_i_2_hash_last).await?;
        // Load stored Bn-1 Ei-3 for new Bn-1 Ei-1.
        let hash = epoch_id_i_2_block_last.next_epoch_id().0.to_string();
        println!("search for: {}", hash);
        let path = format!("{PATH}/{hash}/hash.json");
        let epoch_id_i_3_hash_last: String = fs::read_to_string(path).expect("Hash reading error.");

        let input = client.prepare_input(
            &epoch_id_i_hash_0.to_string(),
            Some(&epoch_id_i_1_hash_last.to_string()),
            &epoch_id_i_1_hash_0,
            &epoch_id_i_2_hash_last,
            Some(&epoch_id_i_3_hash_last)
        ).await.expect("Error prepare input");

        let encoded = to_vec(&input).unwrap();

        let env = ExecutorEnv::builder()
            .write_slice(&encoded)
            .build()
            .unwrap();

        // Obtain the default prover.
        let prover = default_prover();
        let prove_info = match mode {
            Mode::STARK => {
                prover
                    .prove(env, NEAR_RISC0_ELF)
                    .unwrap()
            }
            Mode::SNARK => {
                prover.prove_with_ctx(
                    env,
                    &VerifierContext::default(),
                    NEAR_RISC0_ELF,
                    &ProverOpts::groth16(),
                ).unwrap()
            }
        };

        // Extract the receipt.
        let receipt = prove_info.receipt;

        receipt
            .verify(NEAR_RISC0_ID)
            .unwrap();

        let journal = receipt.journal.bytes.clone();

        let output: PublicValuesEpoch = PublicValuesEpoch::abi_decode(&journal, true)?;

        let previous_hash = CryptoHash(output.previousBlockHash.0);
        let current_hash = CryptoHash(output.currentBlockHash.0);

        println!("Hash B_n-1: {:?}", previous_hash);
        println!("Hash B_0: {:?}", current_hash);
        println!("Height B_n-1: {:?}", output.previousBlockHashHeight);
        println!("Height B_0: {:?}", output.currentBlockHashHeight);


        // Save last known height.
        let last_known_height: u64 = output.currentBlockHashHeight;
        println!("Last known height: {}", last_known_height);
        let last_known_height_str: String = last_known_height.to_string();
        let path = format!("{PATH}/last_known_height.json");
        fs::write(path, last_known_height_str).expect("hash writing error");

        // Save hashes to files.
        let hash = previous_hash.to_string();
        let _ = fs::create_dir_all(format!("{PATH}/{hash}"));
        let path = format!("{PATH}/{hash}/hash.json");
        fs::write(path.clone(), hash).expect("hash writing error");
        let hash = current_hash.to_string();
        let _ = fs::create_dir_all(format!("{PATH}/{hash}"));
        let path = format!("{PATH}/{hash}/hash.json");
        fs::write(path.clone(), hash).expect("hash writing error");
    }
}
