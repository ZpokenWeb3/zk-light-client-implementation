use alloy_sol_types::SolType;

use near_primitives_core::borsh::to_vec;
use near_primitives_core::hash::CryptoHash;
use risc0_zkvm::{default_prover, ExecutorEnv};

use lib::rpc::JsonClient;
use lib::types::types::PublicValuesRandom;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    NEAR_RISC0_ELF, NEAR_RISC0_ID,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let epoch_id_i_hash_i = "Hz5Y8hnxuEdgKbJ34Be88dFoHprsdKQr7JFqDzkms315";

    let mut client = JsonClient::setup(None).expect("Error setup client");
    client.check_rpc_correctness(epoch_id_i_hash_i).await?;

    let (_, epoch_id_i_block_i) = client.load_block_by_hash_from_rpc(epoch_id_i_hash_i).await?;

    // Load Bn-1 Epoch i-2.
    let epoch_id_i_2_hash_last = epoch_id_i_block_i.epoch_id().0;
    let (_, epoch_id_i_2_block_last) = client.load_block_by_hash_from_rpc(epoch_id_i_2_hash_last.to_string().as_str()).await?;
    // Search for this hash in stored hashes.
    let epoch_id_i_2_hash_last_str = epoch_id_i_2_hash_last.to_string();
    println!("search for: {}", epoch_id_i_2_hash_last_str);
    // let path = format!("{PATH}/{hash}/hash.json");
    // let epoch_id_i_2_hash_last_str: String = fs::read_to_string(path).expect("Hash reading error.");
    // Load B0 Epoch i-1 to prove next_bp_hash.
    let mut height: u64 = epoch_id_i_2_block_last.height() + 1;
    // Initialize block.
    let (mut epoch_id_i_1_hash_0, mut epoch_id_i_1_block_0) = (CryptoHash(epoch_id_i_2_hash_last.0), epoch_id_i_2_block_last);
    loop {
        (epoch_id_i_1_hash_0, epoch_id_i_1_block_0) = client.load_block_by_height_from_rpc(height).await?;
        if CryptoHash(epoch_id_i_2_hash_last.0) == CryptoHash(epoch_id_i_1_block_0.prev_hash().0)
            && CryptoHash(epoch_id_i_2_hash_last.0) == CryptoHash(epoch_id_i_1_block_0.next_epoch_id().0.0)
        {
            break;
        }
        height += 1;
    }
    // Search for this hash in stored hashes.
    let epoch_id_i_1_hash_0 = epoch_id_i_1_hash_0.to_string();
    println!("search for: {}", epoch_id_i_1_hash_0);
    // let path = format!("{PATH}/{hash}/hash.json");
    // let epoch_id_i_1_hash_0: String = fs::read_to_string(path).expect("Hash reading error.");

    let input = client.prepare_input(
        &epoch_id_i_hash_i.to_string(),
        None,
        &epoch_id_i_1_hash_0,
        &epoch_id_i_2_hash_last_str,
        None,
    ).await.expect("Error prepare input");

    let encoded = to_vec(&input).unwrap();

    let env = ExecutorEnv::builder()
        .write_slice(&encoded)
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, NEAR_RISC0_ELF)
        .unwrap();

    // Extract the receipt.
    let receipt = prove_info.receipt;

    receipt
        .verify(NEAR_RISC0_ID)
        .unwrap();

    let journal = receipt.journal.bytes.clone();
    let output: PublicValuesRandom = PublicValuesRandom::abi_decode(&journal, true)?;

    let current_block_hash = CryptoHash(output.currentBlockHash.0);
    let previous_epoch_hash_0 = CryptoHash(output.previousEpochHash.0);
    let current_epoch_hash_0 = CryptoHash(output.currentEpochHash.0);

    println!("Current block hash: {}", current_block_hash);
    println!("Previous epoch hash: {}", previous_epoch_hash_0);
    println!("Current epoch hash: {}", current_epoch_hash_0);

    Ok(())
}
